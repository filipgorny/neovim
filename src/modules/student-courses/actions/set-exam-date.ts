import * as R from 'ramda'
import moment from 'moment'
import { validateDateIsFromFuture, validateDateIsFromFutureOrToday } from '../validation/validate-date-is-from-future'
import { findOneOrFail } from '../student-courses-repository'
import { setCalendarStartDate, setExamAtDate, setIsPreReading, setMcatDate, setPreReadingEndDate } from '../student-course-service'
import { buildCalendarEventsForMCAT } from '../../student-calendar-events/utils/mcat-event-builder'
import { DATE_FORMAT_YMD } from '../../../constants'
import { replaceTimeZoneFromUTCToDefault } from '../../notifications/notification-transformers'
import { findOneOrFail as findMcatDate } from '../../mcat-dates/mcat-dates-repository'
import { copyCourseEndDateDays } from '../../student-course-end-date-days/student-course-end-date-days-service'
import { int } from '@desmart/js-utils'
import buildLiveClass from '../../student-calendar-events/actions/build-live-class'
import { deleteAutoGeneratedCalendarEvents } from '../../student-calendar-events/student-calendar-events-service'
import { buildArchivedExams } from '../../student-calendar-events/utils/build-archived-exams'

type Payload = {
  exam_at: string,
  calendar_start_at?: string,
  mcat_date_id?: string,
  build_calendar?: number,
  is_pre_reading?: boolean,
  pre_reading_end_date?: string,
}

export default async (student, courseId: string, payload: Payload) => {
  const { mcat_date_id } = payload
  let { exam_at, calendar_start_at } = payload

  // eslint-disable-next-line no-unneeded-ternary
  const buildCalendar = (payload.build_calendar) ? int(payload.build_calendar) : 1

  let mcatAt

  if (exam_at) {
    validateDateIsFromFuture(exam_at)
  }

  if (calendar_start_at) {
    validateDateIsFromFutureOrToday(calendar_start_at)
  }

  const course = await findOneOrFail({ id: courseId, student_id: student.id })

  if (mcat_date_id) {
    mcatAt = await findMcatDate({ id: mcat_date_id, course_id: course.book_course_id })

    validateDateIsFromFuture(mcatAt.mcat_date, 'mcat_date')
  }

  if (course.type === 'on_demand' && !calendar_start_at) {
    const metadata = JSON.parse(course.metadata)

    // we do this only for one-week courses (new flow)
    if (int(metadata.days_amount) === 7) {
      calendar_start_at = moment().format(DATE_FORMAT_YMD)
      exam_at = moment().add(7, 'days').format(DATE_FORMAT_YMD)
    }
  }

  await setExamAtDate(course.id, replaceTimeZoneFromUTCToDefault(moment(exam_at)).format(DATE_FORMAT_YMD))
  await setCalendarStartDate(course.id, replaceTimeZoneFromUTCToDefault(moment(calendar_start_at)).format(DATE_FORMAT_YMD) || moment().format(DATE_FORMAT_YMD))
  await setIsPreReading(course.id, payload.is_pre_reading || false)

  if (payload.is_pre_reading) {
    await setPreReadingEndDate(course.id, replaceTimeZoneFromUTCToDefault(moment(payload.pre_reading_end_date)).format(DATE_FORMAT_YMD))
  }

  if (mcatAt) {
    await setMcatDate(course.id, mcatAt.id)
  }

  const updatedCourse = await findOneOrFail({ id: courseId, student_id: student.id })

  await copyCourseEndDateDays(updatedCourse)

  if (buildCalendar === 1) {
    await buildArchivedExams(updatedCourse)
    await buildCalendarEventsForMCAT(updatedCourse)
  } else if (buildCalendar === -1) {
    await buildCalendarEventsForMCAT(updatedCourse, false, true)
    await buildArchivedExams(updatedCourse)
  } else if (buildCalendar === -3) {
    await deleteAutoGeneratedCalendarEvents(updatedCourse)
    await buildArchivedExams(updatedCourse)
    await buildLiveClass(updatedCourse)
  }

  return updatedCourse
}
