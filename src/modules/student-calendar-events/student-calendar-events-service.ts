import * as R from 'ramda'
import { int } from '@desmart/js-utils'
import mapP from '@desmart/js-utils/dist/function/mapp'
import { create, patch, deleteRecord, find, findOne, findEventsAfterAvailableToDate } from './student-calendar-events-repository'
import { findOne as findStudentExam } from '../student-exams/student-exam-repository'
import { StudentCourse } from '../../types/student-course'
import { collectionToJson } from '../../../utils/model/collection-to-json'
import { CalendarEventType } from './calendar-event-type'
import { CalendarEventStatus } from './calendar-event-status'

export const createEntity = async (dto: {}) => (
  create(dto)
)

export const patchEntity = async (id: string, dto: {}) => (
  patch(id, dto)
)

const awaitAllInObject = async (obj) => {
  const values = await Promise.all(Object.values(obj))
  const keys = Object.keys(obj)
  const result = {}

  for (let i = 0; i < keys.length; i++) {
    result[keys[i]] = values[i]
  }

  return result
}

export const reorderCalendarEvents = async (ids: string[]) => (
  awaitAllInObject(
    R.mapObjIndexed(async (id, index) => patchEntity(id, { order: int(index) + 1 }), ids)
  )
)

export const increaseCalendarEventsOrderByOne = async (events: []) => (
  awaitAllInObject(
    R.mapObjIndexed(async (event, index) => patchEntity(event.id, { order: int(event.order) + 1 }), events)
  )
)

export const fetchAndReorderCalendarEvents = async (studentCourse: StudentCourse, date: Date) => {
  const events = await find({ limit: { page: 1, take: 100 }, order: { by: 'order', dir: 'asc' } }, { student_course_id: studentCourse.id, event_date: date })

  const eventIds = R.pipe(
    R.prop('data'),
    collectionToJson,
    R.pluck('id')
  )(events)

  // Reorder the calendar events using reorderCalendarEvents
  await reorderCalendarEvents(eventIds)
}

export const deleteCalendarEvent = async (id: string) => (
  deleteRecord(id)
)

type CalendarEventPayload = {
  title: string,
  event_date: string,
  duration: number,
  action_uri: string,
  event_colour: string,
  student_item_id?: string,
  student_exam_id?: string,
  student_exam_ids?: string,
  description?: string,
  status?: string,
  is_manual?: boolean,
  from_manual_setup?: boolean,
  class_time?: string,
  class_time_end?: string,
  is_locked_in_free_trial?: boolean,
  original_exam_id?: string,
  parent_event_id?: string,
  free_trial_featured_exam?: boolean,
}

const getNextOrder = async (studentCourse: StudentCourse, date: string) => {
  const events = await find({ limit: { page: 1, take: 100 }, order: { by: 'order', dir: 'desc' } }, { student_course_id: studentCourse.id, event_date: date })

  return int(events.meta.recordsTotal) + 1
}

export const createCalendarEvent = async (studentCourse: StudentCourse, eventType: CalendarEventType, payload: CalendarEventPayload, isManual = false) => {
  // If the original exam has been deleted, do not create the event
  if (payload.student_exam_id) {
    const studentExam = await findStudentExam({ id: payload.student_exam_id }, ['originalExam'])

    if (studentExam.originalExam.deleted_at) {
      return null
    }
  }

  // Same goes for "other exams" but it's a bit different
  if (eventType === CalendarEventType.otherExam && payload.student_item_id) {
    const studentExam = await findStudentExam({ id: payload.student_item_id }, ['originalExam'])

    if (studentExam?.originalExam?.deleted_at) {
      return null
    }
  }

  const nextOrder = await getNextOrder(studentCourse, payload.event_date)

  return create({
    ...payload,
    student_course_id: studentCourse.id,
    type: eventType,
    status: payload.status || CalendarEventStatus.incomplete,
    order: nextOrder,
    is_manual: isManual,
    from_manual_setup: payload.from_manual_setup || false,
  })
}

const skipArchivedEvents = R.reject(R.propEq('status', CalendarEventStatus.archived))

export const deleteAutoGeneratedCalendarEvents = async (studentCourse: StudentCourse, skipArchived = false, andWhere = {}) => {
  const events = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, is_manual: false, ...andWhere })

  const eventIds = R.pipe(
    R.prop('data'),
    collectionToJson,
    R.when(
      (events) => skipArchived,
      skipArchivedEvents
    ),
    R.pluck('id')
  )(events)

  await mapP(
    async id => deleteCalendarEvent(id)
  )(eventIds)
}

export const deleteAutoGeneratedIncompleteCalendarEvents = async (studentCourse: StudentCourse) => {
  const events = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, is_manual: false, status: CalendarEventStatus.incomplete })

  const eventIds = R.pipe(
    R.prop('data'),
    collectionToJson,
    R.pluck('id')
  )(events)

  await mapP(
    async id => deleteCalendarEvent(id)
  )(eventIds)
}

export const deletePreReadingCalendarEvents = async (studentCourse: StudentCourse) => {
  const events = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.bookLinkPreReading })

  const eventIds = R.pipe(
    R.prop('data'),
    collectionToJson,
    R.pluck('id')
  )(events)

  await mapP(
    async id => deleteCalendarEvent(id)
  )(eventIds)
}

export const deleteIncompletePreReadingCalendarEvents = async (studentCourse: StudentCourse) => {
  const events = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.bookLinkPreReading, status: CalendarEventStatus.incomplete })

  const eventIds = R.pipe(
    R.prop('data'),
    collectionToJson,
    R.pluck('id')
  )(events)

  await mapP(
    async id => deleteCalendarEvent(id)
  )(eventIds)
}

export const deleteCustomExamsCalendarEvents = async (studentCourse: StudentCourse) => {
  const eventsA = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.customFullLengthExam })
  const eventsB = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.customFullLengthExamReview })
  const eventsC = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.customSectionExam })
  const eventsD = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.customSectionExamReview })

  const events = [...eventsA.data, ...eventsB.data, ...eventsC.data, ...eventsD.data]

  const eventIds = R.pipe(
    collectionToJson,
    R.pluck('id')
  )(events)

  await mapP(
    async id => deleteCalendarEvent(id)
  )(eventIds)
}

export const deleteLiveClassIncompleteCalendarEvents = async (studentCourse: StudentCourse) => {
  const eventsA = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.liveClass, status: CalendarEventStatus.incomplete })
  const eventsB = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.bookLink, status: CalendarEventStatus.incomplete })
  const eventsC = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.fullLengthExam, status: CalendarEventStatus.incomplete })
  const eventsD = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.fullLengthExamReview, status: CalendarEventStatus.incomplete })
  const eventsE = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.chapterExam, status: CalendarEventStatus.incomplete })
  const eventsF = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.chapterExamReview, status: CalendarEventStatus.incomplete })
  const eventsG = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, type: CalendarEventType.customEndDateEvent, status: CalendarEventStatus.incomplete })

  const events = [...eventsA.data, ...eventsB.data, ...eventsC.data, ...eventsD.data, ...eventsE.data, ...eventsF.data, ...eventsG.data]

  const eventIds = R.pipe(
    collectionToJson,
    R.pluck('id')
  )(events)

  await mapP(
    async id => deleteCalendarEvent(id)
  )(eventIds)
}

export const markEventAsCompletedByStudentItemId = async (student_item_id: string) => {
  const event = await findOne({ student_item_id }) // add filtering to make sure we fetch the exam event, not the review event

  console.log('markEventAsCompletedByStudentItemId event', event)

  if (event) {
    return patchEntity(event.id, { status: CalendarEventStatus.complete })
  }

  console.log(event)

  return true
}

export const markEventAsCompletedByStudentCourseAndStudentItemId = async (student_course_id: string, student_item_id: string) => {
  const event = await findOne({ student_item_id, student_course_id })

  if (event) {
    return patchEntity(event.id, { status: CalendarEventStatus.complete })
  }

  return true
}

const safeParse = input => {
  // Check if the input is a string
  if (typeof input === 'string') {
    try {
      // Attempt to parse the JSON string
      return JSON.parse(input)
    } catch (error) {
      // If parsing fails, log the error and return null
      console.error('Failed to parse JSON:', error)
      return null
    }
  }

  // If input is already an object, return it as is
  return input
}

/**
 * For a course that is shorter than 90 days:
 * NOT TRUE ANYMORE: Events that were locked, go to the archive box. Events that were unlocked in the free trial stay in the calendar.
 * CURRENT STATUS: All events are simply unlocked and stay in the calendar
 *
 * For a course that is 90 days or longer:
 * Events are unlocked and stay in place on the calendar
 */
export const archiveEventsLockedInFreeTrial = async (studentCourse: StudentCourse, daysAmount: number) => {
  if (int(daysAmount) >= 90) {
    console.log('Course is 90 days or longer')

    const events = await find({ limit: { page: 1, take: 1000 }, order: { by: 'title', dir: 'asc' } }, { student_course_id: studentCourse.id, is_locked_in_free_trial: true })

    const eventIds = R.pipe(
      R.prop('data'),
      collectionToJson,
      R.pluck('id')
    )(events)

    await mapP(
      async id => patchEntity(id, { is_locked_in_free_trial: false })
    )(eventIds)
  } else {
    console.log('Course is shorter than 90 days')

    console.log('accessible_to:', studentCourse.accessible_to)
    const events = await findEventsAfterAvailableToDate(studentCourse)

    const eventIds = R.pipe(
      R.pluck('id')
    )(events)

    await mapP(
      async id => patchEntity(id, { is_locked_in_free_trial: false })
    )(eventIds)
  }

  return true
}
